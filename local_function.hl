#ifndef MATRIX_PRIVATE_HL
# define MATRIX_PRIVATE_HL

#include "matrix.hl"

t_vector		local_matrix_get_mult_dir_vector(__local t_matrix *m, const t_vector *v);
t_vector		local_matrix_get_mult_vector(__local t_matrix *m, const t_vector *v);
t_vector		local_vector_get_sub(const t_vector *a, __local t_vector *b);


t_vector		local_matrix_get_mult_vector(__local t_matrix *m, const t_vector *v)
{
	t_vector	new;
	float		len;

	new.x = (m->matrix[0][0] * v->x) + (m->matrix[0][1] * v->y) + (m->matrix[0][2] * v->z) + (m->matrix[0][3]);
	new.y = (m->matrix[1][0] * v->x) + (m->matrix[1][1] * v->y) + (m->matrix[1][2] * v->z) + (m->matrix[1][3]);
	new.z = (m->matrix[2][0] * v->x) + (m->matrix[2][1] * v->y) + (m->matrix[2][2] * v->z) + (m->matrix[2][3]);
	len =   (m->matrix[3][0] * v->x) + (m->matrix[3][1] * v->y) + (m->matrix[3][2] * v->z) + (m->matrix[3][3]);

	new.x /= len;
	new.y /= len;
	new.z /= len;

	return (new);
}

t_vector		local_matrix_get_mult_dir_vector(__local t_matrix *m, const t_vector *v)
{
	t_vector	n;

	n.x = (v->x * m->matrix[0][0]) + (v->y * m->matrix[0][1]) + (v->z * m->matrix[0][2]);
	n.y = (v->x * m->matrix[1][0]) + (v->y * m->matrix[1][1]) + (v->z * m->matrix[1][2]);
	n.z = (v->x * m->matrix[2][0]) + (v->y * m->matrix[2][1]) + (v->z * m->matrix[2][2]);

	return (n);
}

t_vector		local_vector_get_sub(const t_vector *a, __local t_vector *b)
{
	t_vector new;

	new.x = a->x - b->x;
	new.y = a->y - b->y;
	new.z = a->z - b->z;

	return (new);
}

#endif
